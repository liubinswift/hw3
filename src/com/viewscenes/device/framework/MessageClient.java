/* Generated by Together */



package com.viewscenes.device.framework;



import com.viewscenes.device.exception.*;
import com.viewscenes.device.util.*;

import com.viewscenes.util.LogTool;
import com.viewscenes.pub.GDSet;
import com.viewscenes.dao.database.DbComponent;
import com.viewscenes.dao.database.*;




/**

 * <pre>

 * 该类是客户向设备收发消息的接口和控制器，类似于接收设备消息的控制器MessageServer

 * 由于收发过程都是一样的，因此该类的方法具有固定的编码

 * 如果广播消息，有线消息等处理过程不同，则该类应该定义为接口，具体的实现类实现具体的过程

 * 目前使用同一类，发现有分开的需求时可以Refactoring

 * 该类实现了IMessageListener，用于消息的异步通知

 * </pre>

 * @see FilterManager

 * @see ProcessorManager

 * @see MessageRegister

 */

public class MessageClient implements IMessageListener {

  private IMessage msg;

  private String msgID;

  private boolean timeout;

  private int seconds;

  static boolean bUserProxy = false;


  /**

   * <pre>

   * 收发，处理消息，向MessageRegister注册为“消息返回”事件的“观察者”

   * 若在指定的时间内收不到“消息返回”事件，则注销自己“观察者”的身份并返回

   * </pre>

   * @param cmdObj 待发送的下行消息

   * @param rspObj 返回的上行消息

   * @preconditions cmdObj != null && rspObj != null

   * @throws DeviceFilterException

   * @throws DeviceProcessException

   * @throws DeviceTimedOutException

   * @throws DeviceReportException

   */

  public synchronized void execute(BaseMessageCommand cmdObj,

                                   BaseMessageResponse rspObj) throws

      DeviceFilterException, DeviceProcessException, DeviceTimedOutException,

      DeviceReportException {

    IMessage msgToDevice = cmdObj.getMessage();
    try {

        msgID = msgToDevice.getMsgID();

      msgToDevice = fm.doFilter(msgToDevice);

      MessageRegister.addObserver(msgID, this);

        pm.doProcess(msgToDevice);

      int msgTime = cmdObj.getTimedout() * 1000;

      synchronized(this){
        wait(msgTime);
      }

      if (msg == null) {
        throw new DeviceTimedOutException("设备无响应：超时");
      }

      rspObj.setMessage(msg);

    } catch (InterruptedException e) {

//      LogTool.debug("devicelog", e);

    } finally {

      MessageRegister.removeObserver(msgID);

    }

  }



  /**

   * IMessageListener定义的方法，作为“观察者”时的回调函数，消息返回后被调用

   * @param response 返回的上行消息

   * @preconditions response != null

   * @see IMessageListener

   */

  public void onMessage(IMessage response) {

    this.msg = response;

  }



  private static FilterManager fm = new FilterManager("down");

  private static ProcessorManager pm = new ProcessorManager("down");


}
