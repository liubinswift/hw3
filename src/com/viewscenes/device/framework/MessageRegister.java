/* Generated by Together */

package com.viewscenes.device.framework;

import java.util.*;

import org.jdom.*;

import com.viewscenes.device.util.*;

import com.viewscenes.util.LogTool;

/**

 * <pre>

 * 该类和IMessageListener，消息接收者之间构成了简单的观察者模式

 * java.util.Observer和java.util.Observable为观察者模式提供了缺省实现

 * 但此处对每一事件(特定消息ID的消息返回)只有一个观察者，不适合使用缺省实现

 * 如果将事件定义为任何ID的消息返回，则可以使用java.util.Observer等

 * </pre>

 * @pattern Singleton，Observer

 * @see IMessageListener

 */

public class MessageRegister {


  private static Map listeners;

  private Collection reportListeners;

  private Collection proxyListeners;
  public static MessageRegister register = null;

  public MessageRegister() {
    initRegister();
  }

  void initRegister(){

    if (listeners==null){
      listeners = new LinkedHashMap();
    }

    try {

      Element report = MsgUtil.getConfigItem("reportlistenner");
      if (report!=null){
        List children = report.getChildren();

        if (children!=null&&!children.isEmpty()) {

          reportListeners = new HashSet();

          for (Iterator it = children.iterator(); it.hasNext(); ) {

            reportListeners.add(Class.forName(

                ( (Element) it.next()).getAttributeValue("class")).newInstance());

          }

        }
      }

    } catch (Exception ex) {

      LogTool.fatal("devicelog", ex);

    }
    try {
      Element proxy = MsgUtil.getConfigItem("proxylistenner");
      if (proxy != null) {
        List children = proxy.getChildren();

        if (children != null && !children.isEmpty()) {

          proxyListeners = new HashSet();

          for (Iterator it = children.iterator(); it.hasNext(); ) {

            proxyListeners.add(Class.forName(

                ( (Element) it.next()).getAttributeValue("class")).newInstance());
          }
        }
      }
      }
      catch (Exception ex) {

        LogTool.fatal("devicelog", ex);

      }


  }

  /**

   * 注册处理消息ID为msgID的IMessageListener对象，等候消息返回的通知

   * @param msgID 消息ID

   * @param msgListener 观察者

   * @preconditions msgID != null && msgListener != null

   * @postconditions can get IMessageListener by msgID

   */

  public static synchronized void addObserver(Object msgID,

                                       IMessageListener msgListener) {
    if (listeners==null)
      listeners = new LinkedHashMap();

    listeners.put(msgID, msgListener);

  }



  /**

   * 等候返回超时时，由外部调用，取消等待

   * @param msgID 消息ID

   * @preconditions msgID != null

   * @postconditions can't get IMessageListener by msgID

   */

  public static synchronized void removeObserver(Object msgID) {
    if (listeners==null)
      listeners = new LinkedHashMap();
    listeners.remove(msgID);

  }



  /**

   * 注册处理主动上报消息的IMessageListener对象，等候消息上报的通知

   * @param msgListener 观察者

   * @preconditions msgListener != null

   */

  public synchronized void addReportObserver(IMessageListener msgListener) {

    reportListeners.add(msgListener);

  }



  /**

   * 不再处理主动上报消息时，由外部调用，取消等待

   * @param msgListener 取消监听主动上报消息的IMessageListener对象

   * @preconditions msgListener != null

   */

  public synchronized void removeReportObserver(IMessageListener msgListener) {

    reportListeners.remove(msgListener);

  }

  /**

   * 消息返回时，通知等待的IMessageListener对象

   * @param msg 接收到的消息对象

   * @preconditions msg != null

   * @postconditions

   * <pre>

   * 对于查询返回，对应msg'replyID的IMessageListener对象将得到消息

   * 对于主动上报，对应主动上报的IMessageListener对象将得到消息

   * </pre>

   */

  public synchronized void notify(IMessage msg) {

    //assert msg != null;

    Object msgID = ( (UpMessage) msg).getReplyID();

    long msgIDValue = Long.parseLong( (String) msgID);

    if (msgIDValue == -1) {

      //主动上报

      if (reportListeners != null) {

        for (Iterator it = reportListeners.iterator(); it.hasNext(); ) {

          ( (IMessageListener) it.next()).onMessage(msg);

        }

      }

    }

    else {
      //查询返回
      MessageClient client = (MessageClient)listeners.get(msgID);
      if (client==null)
      {

              /**
               * 原因：在v7版本中实时监测第一次报成功后，第二次上报的数据不是为自动上报格式。在这里进行强制扔到自动上报业务逻辑中去。
               */
              if (reportListeners != null) {

              for (Iterator it = reportListeners.iterator(); it.hasNext(); ) {

                  ((IMessageListener) it.next()).onMessage(msg);

              }

          }
          return;
      }
      client.onMessage(msg);
      synchronized(client){
          client.notify();
      }
      }
    }
}




