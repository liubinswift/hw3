 /* Generated by Together */



package com.viewscenes.device.util;



import java.util.*;



import org.jdom.*;
import com.viewscenes.pub.GDSet;
import com.viewscenes.dao.database.DbComponent;



/**

 * <pre>

 * 对设备的抽象，具有类型，URL等属性

 * 该类具有不变性，且数量有限，可在系统中共享

 * 系统初始化时，读取数据源构造系统中所有设备，放入池中共享使用

 * </pre>

 * @pattern flyweight

 * @version 1.0

 */

public final class InnerDevice {

  private InnerDevice(String code, InnerMsgType type, String url) {

    this.code = code;

    this.type = type;

    this.url = url;

  }



  /**

   * 得到该设备的编码

   * @return 设备的编码

   */

  public String getCode() {

    return code;

  }



  /**

   * 得到该设备支持的消息版本

   * 内部可使用 map 在内存中维持一份对应表，数据来源可以是数据库或配置文件

   * @return 设备支持的版本

   */

  public InnerMsgType getType() {

    return type;

  }
  /**

   * 设置该设备支持的消息版本

   * 内部可使用 map 在内存中维持一份对应表，数据来源可以是数据库或配置文件

   * @return 设备支持的版本

   */

  public void setType(String type) {



  }


  /**

   * 得到该设备接收消息的URL

   * 内部可使用 map 在内存中维持一份对应表，数据来源可以是数据库或配置文件

   * @return 设备的URL

   */

  public String getURL() {

    return url;

  }



  public static InnerDevice instance(String code) {
          /**
           *  修改此方法,当有新站点增加的时候刷新内存.
           */
        InnerDevice device= (InnerDevice)devices.get(code);
          if(device==null)
          {

                  /**
              * 刘斌业务修改，可以一个站点支持多种类型,可以支持ｖ４，ｖ５，ｖ６，ｖ７，ｖ７和新增边境版本。
              */
             /**
                * 原因:原来由于这里进行系统访问数据库比较频繁,所以系统启动时把所有的站点都配置到配置文件中,
                *     系统启动时放到缓存中.
                *     优点:  数据库访问减少,速度也较快.
                *     缺点:  但是如果页面新增一个站点时需要修改配置文件,并且要重启系统.
                * 修改:目前考虑解决方案为不从配置文件中拿数据,一次性从数据库中拿数据,缓存数据不变,只有当新增站点后应重新刷新缓存.不需要修改配置文件.
              */
        GDSet result_set=null;
           String valueSql =
               " select code,version,url ,type_id from res_headend_tab t  where t.is_delete=0" ;
            try{
                result_set = DbComponent.Query(valueSql);
                if(devices.isEmpty())
                {
                  devices.clear();
                }
                if(deviceType.isEmpty())
                {
                   devices.clear();
                }
                devices = new HashMap(result_set.getRowCount());
                deviceType = new HashMap(result_set.getRowCount());

                for (int i = 0; i < result_set.getRowCount(); i++) {

                    String deviceCode = result_set.getString(i, "code");

                    String codeType = result_set.getString(i, "type_id");
                    String version = result_set.getString(i, "version");
                    version = version.substring(1, version.length());
                    String url = result_set.getString(i, "url");
                    if (codeType.equals("103")) {
                        deviceType.put(deviceCode, "1");
                        /**
                         * 这个也必须要加,因为后来要根据IMessage对象拿到下发的url
                         */

                        devices.put(deviceCode, new InnerDevice(

                                deviceCode,

                                InnerMsgType.instance("common1"),

                                url));

                        devices.put(deviceCode +
                                    "radio",
                                    new InnerDevice(

                                            deviceCode,

                                            InnerMsgType.instance("radio" +
                                version),

                                            url));
                        devices.put(deviceCode +
                                    "tv",
                                    new InnerDevice(

                                            deviceCode,

                                            InnerMsgType.instance("tv" + version),

                                            url));
                        devices.put(deviceCode +
                                    "common",
                                    new InnerDevice(

                                            deviceCode,

                                            InnerMsgType.instance("common" +
                                version),

                                            url));

                    } else {
                        deviceType.put(deviceCode, "2");
                        devices.put(deviceCode, new InnerDevice(

                                deviceCode,

                                InnerMsgType.instance("radio" + version),

                                url));

                    }

                }
            }   catch(Exception e)
            {
                e.printStackTrace();
            }
             device= (InnerDevice)devices.get(code);
          }
          return device;

  }
  public synchronized static void  refreshInstance() {
          /**
           *  修改此方法,当有新站点增加的时候刷新内存.
           */

                  /**
              * 刘斌业务修改，可以一个站点支持多种类型,可以支持ｖ４，ｖ５，ｖ６，ｖ７，ｖ７和新增边境版本。
              */
             /**
                * 原因:原来由于这里进行系统访问数据库比较频繁,所以系统启动时把所有的站点都配置到配置文件中,
                *     系统启动时放到缓存中.
                *     优点:  数据库访问减少,速度也较快.
                *     缺点:  但是如果页面新增一个站点时需要修改配置文件,并且要重启系统.
                * 修改:目前考虑解决方案为不从配置文件中拿数据,一次性从数据库中拿数据,缓存数据不变,只有当新增站点后应重新刷新缓存.不需要修改配置文件.
              */
        GDSet result_set=null;
           String valueSql =
               " select code,version,url ,type_id from res_headend_tab t  where t.is_delete=0" ;
            try{
                result_set = DbComponent.Query(valueSql);
                if(devices.isEmpty())
                {
                  devices.clear();
                }
                if(deviceType.isEmpty())
                {
                   devices.clear();
                }
                devices = new HashMap(result_set.getRowCount());
                deviceType = new HashMap(result_set.getRowCount());
                for (int i = 0; i < result_set.getRowCount(); i++) {

                    String deviceCode = result_set.getString(i, "code");

                    String codeType = result_set.getString(i, "type_id");
                    String version = result_set.getString(i, "version");
                    version = version.substring(1, version.length());
                    String url = result_set.getString(i, "url");
                    if (codeType.equals("103")) {
                        deviceType.put(deviceCode, "1");
                        /**
                         * 这个也必须要加,因为后来要根据IMessage对象拿到下发的url
                         */

                        devices.put(deviceCode, new InnerDevice(

                                deviceCode,

                                InnerMsgType.instance("common1"),

                                url));

                        devices.put(deviceCode +
                                    "radio",
                                    new InnerDevice(

                                            deviceCode,

                                            InnerMsgType.instance("radio" +
                                version),

                                            url));
                        devices.put(deviceCode +
                                    "tv",
                                    new InnerDevice(

                                            deviceCode,

                                            InnerMsgType.instance("tv" + version),

                                            url));
                        devices.put(deviceCode +
                                    "common",
                                    new InnerDevice(

                                            deviceCode,

                                            InnerMsgType.instance("common" +
                                version),

                                            url));

                    } else {
                        deviceType.put(deviceCode, "2");
                        devices.put(deviceCode, new InnerDevice(

                                deviceCode,

                                InnerMsgType.instance("radio" + version),

                                url));

                    }

                }
            }   catch(Exception e)
            {
                e.printStackTrace();
            }



  }

  //得到设备是遥控站还是边境。1为边境，2为遥控站
  public static String deviceType(String code) {

     return (String)deviceType.get(code);

  }


  private InnerMsgType type;

  private String code;

  private String url;

  private static Map devices;
  //判断设备是边境还是遥控站。
  private static Map deviceType;
  static {
          /**
           * 刘斌业务修改，可以一个站点支持多种类型,可以支持ｖ４，ｖ５，ｖ６，ｖ７，ｖ8和新增边境版本。
           */
          /**
             * 原因:原来由于这里进行系统访问数据库比较频繁,所以系统启动时把所有的站点都配置到配置文件中,
             *     系统启动时放到缓存中.
             *     优点:  数据库访问减少,速度也较快.
             *     缺点:  但是如果页面新增一个站点时需要修改配置文件,并且要重启系统.
             * 修改:目前考虑解决方案为不从配置文件中拿数据,一次性从数据库中拿数据,缓存数据不变,只有当新增站点后应重新刷新缓存.不需要修改配置文件.
           */
     GDSet result_set=null;
        String valueSql =
            " select code,version,url ,type_id from res_headend_tab t  where t.is_delete=0" ;
         try{
             result_set = DbComponent.Query(valueSql);

             devices = new HashMap(result_set.getRowCount());
             deviceType = new HashMap(result_set.getRowCount());

             for (int i = 0; i < result_set.getRowCount(); i++) {

                 String deviceCode = result_set.getString(i, "code");

                 String codeType = result_set.getString(i, "type_id");
                 String version = result_set.getString(i, "version");
                 version = version.substring(1, version.length());
                 String url = result_set.getString(i, "url");
                 if (codeType.equals("103")) {
                     deviceType.put(deviceCode, "1");
                     /**
                      * 这个也必须要加,因为后来要根据IMessage对象拿到下发的url
                      */

                     devices.put(deviceCode, new InnerDevice(

                             deviceCode,

                             InnerMsgType.instance("common1"),

                             url));

                     devices.put(deviceCode +
                                 "Radio",
                                 new InnerDevice(

                                         deviceCode,

                                         InnerMsgType.instance("radio" +
                             version),

                                         url));
                     devices.put(deviceCode +
                                 "TV",
                                 new InnerDevice(

                                         deviceCode,

                                         InnerMsgType.instance("tv" + version),

                                         url));
                     devices.put(deviceCode +
                                 "common",
                                 new InnerDevice(

                                         deviceCode,

                                         InnerMsgType.instance("common" +
                             version),

                                         url));

                 } else {
                     deviceType.put(deviceCode, "2");
                     devices.put(deviceCode, new InnerDevice(

                             deviceCode,

                             InnerMsgType.instance("radio" + version),

                             url));

                 }

             }
         }   catch(Exception e)
         {
             e.printStackTrace();
         }

  }

}
